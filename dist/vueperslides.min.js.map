{"version":3,"file":"vueperslides.min.js","sources":["../src/components/VueperSlide.vue","../src/components/VueperSlides.vue","../src/index.js"],"sourcesContent":["<template lang=\"pug\">\ndiv(:class=\"{ 'vueperslides__slide': true, 'vueperslides__slide--active': $parent.slides.activeUid === _uid }\" :style=\"styles\")\n  div.vueperslides__slide-content(v-if=\"!$parent.conf.slideContentOutside && (title || content)\")\n    p.slide-title(v-html=\"title\")\n    p.slide-content(v-html=\"content\")\n</template>\n\n<script>\nexport default {\n  props: {\n    clone: {\n      type: Number,\n      default: null\n    },\n    image: {\n      type: String,\n      default: ''\n    },\n    title: {\n      type: String,\n      default: ''\n    },\n    content: {\n      type: String,\n      default: ''\n    }\n  },\n  created () {\n    this.$parent.addSlide({\n      _uid: this._uid,\n      image: this.image,\n      title: this.title,\n      content: this.content,\n      clone: this.clone\n    })\n  },\n  // When removing a slide programmatically, remove it from the config so vueperslides\n  // component is aware of the change.\n  destroyed () {\n    if (this.clone === null) this.$parent.removeSlide(this._uid)\n  },\n  computed: {\n    styles () {\n      return { ...(this.image && { backgroundImage: `url(${this.image})` }) }\n    }\n  }\n}\n</script>\n","<template lang=\"pug\">\ndiv.vueperslides(:class=\"{'vueperslides--ready': isReady, 'vueperslides--fade': conf.fade, 'vueperslides--parallax': conf.parallax, 'vueperslides--touchable': touch.enabled && !disable }\" ref=\"vueperslides\")\n  div.vueperslides__slide-content.vueperslides__slide-content--outside(:class=\"conf.slideContentOutsideClass\" v-if=\"conf.slideContentOutside\")\n    p.slide-title(v-if=\"slides.count && slides.list[slides.current].title\" v-html=\"slides.list[slides.current].title\")\n    p.slide-content(v-if=\"slides.count && slides.list[slides.current].content\" v-html=\"slides.list[slides.current].content\")\n\n  div.vueperslides__inner\n    div.vueperslides__parallax-wrapper(:style=\"'padding-bottom:' + (this.conf.slideRatio * 100) + '%'\")\n      div.vueperslides__track-wrapper(:style=\"conf.parallax ? 'transform: translateY(-' + parallaxData.translation + '%)' : ''\")\n        div.vueperslides__track(:class=\"{'vueperslides__track--dragging': touch.dragging, 'vueperslides__track--mousedown': mouseDown}\" ref=\"track\" :style=\"!conf.fade ? 'transform: translate3d(' + currentTranslation + '%, 0, 0)' : ''\")\n          vueper-slide.vueperslides__slide--clone(v-if=\"slides.count && clones[0]\" :clone=\"0\" :title=\"clones[0].title\" :content=\"clones[0].content\" :image=\"clones[0].image\" :style=\"clones[0].style\")\n          slot(:currentSlide=\"slides.current\")\n          vueper-slide.vueperslides__slide--clone(v-if=\"slides.count && clones[1]\" :clone=\"1\" :title=\"clones[1].title\" :content=\"clones[1].content\" :image=\"clones[1].image\" :style=\"clones[1].style\")\n\n    div.vueperslides__paused(v-if=\"$slots.pausedIcon\")\n      slot(name=\"pausedIcon\")\n    div.vueperslides__arrows(v-if=\"conf.arrows && slides.count > 1 && !disable\")\n      button.vueperslides__arrow.vueperslides__arrow--prev(@click=\"onArrowClick(false)\" v-show=\"!arrowPrevDisabled\")\n        slot(name=\"arrowLeft\")\n          svg(viewBox=\"0 0 24 24\")\n            path(d=\"M16.2,21c0.3,0,0.5-0.1,0.7-0.3c0.4-0.4,0.4-1,0-1.4L9.6,12L17,4.7c0.4-0.4,0.4-1,0-1.4c-0.4-0.4-1-0.4-1.4,0L6.8,12l8.8,8.7C15.7,20.9,16,21,16.2,21z\")\n      button.vueperslides__arrow.vueperslides__arrow--next(@click=\"onArrowClick()\" v-show=\"!arrowNextDisabled\")\n        slot(name=\"arrowRight\")\n          svg(viewBox=\"0 0 24 24\")\n            path(d=\"M7.8,21c-0.3,0-0.5-0.1-0.7-0.3c-0.4-0.4-0.4-1,0-1.4l7.4-7.3L7,4.7c-0.4-0.4-0.4-1,0-1.4s1-0.4,1.4,0l8.8,8.7l-8.8,8.7C8.3,20.9,8,21,7.8,21z\")\n  div.vueperslides__bullets(:class=\"{'vueperslides__bullets--outside': conf.bulletsOutside}\" v-if=\"conf.bullets && slides.count > 1 && !disable\")\n    button.vueperslides__bullet(:class=\"{'vueperslides__bullet--active': slides.current === i}\" v-for=\"(item, i) in slides.list\" :key=\"i\" @click=\"goToSlide(i)\" @keyup.left=\"onArrowClick(false)\" @keyup.right=\"onArrowClick()\" ref=\"bullet\")\n      span {{ i + 1 }}\n</template>\n\n<script>\nimport VueperSlide from './VueperSlide.vue'\n\nexport default {\n  name: 'vueper-slides',\n  components: { VueperSlide },\n  props: {\n    initSlide: {\n      type: Number,\n      default: 1\n    },\n    slideRatio: {\n      type: Number,\n      default: 1/3\n    },\n    arrows: {\n      type: Boolean,\n      default: true\n    },\n    // Ability to disable arrows on slideshow edges. Only if not infinite mode.\n    disableArrowsOnEdges: {\n      type: [Boolean, String],\n      default: false\n    },\n    bullets: {\n      type: Boolean,\n      default: true\n    },\n    bulletsOutside: {\n      type: Boolean,\n      default: false\n    },\n    fade: {\n      type: Boolean,\n      default: false\n    },\n    slideContentOutside: {\n      type: Boolean,\n      default: false\n    },\n    slideContentOutsideClass: {\n      type: String,\n      default: ''\n    },\n    autoplay: {\n      type: Boolean,\n      default: false\n    },\n    speed: {\n      type: [Number, String],\n      default: 4000\n    },\n    pauseOnHover: {\n      type: Boolean,\n      default: true\n    },\n    infinite: {\n      type: Boolean,\n      default: true\n    },\n    parallax: {\n      type: Boolean,\n      default: false\n    },\n    touchable: {\n      type: Boolean,\n      default: true\n    },\n    // By default when touch is enabled you have to drag from a slide side and pass 50% of slideshow width to change\n    // slide. This setting changes this behavior to a horizontal pixel amount from anywhere on slideshow.\n    draggingDistance: {\n      type: Number,\n      default: null\n    },\n    disable: {\n      type: Boolean,\n      default: false\n    },\n    breakpoints: {\n      type: Object,\n      default: () => ({})\n    }\n  },\n  data: () => ({\n    isReady: false,\n    container: null,\n    slides: { list: [], count: 0, activeUid: null, current: 0, clones: [] },\n    clones: [],\n    mouseDown: false,\n    mouseOver: false,\n    touch: { enabled: true, dragging: false, dragStartX: 0, dragAmount: 0, goNext: true },\n    currentTranslation: 0,\n    timer: null,\n    arrowPrevDisabled: false,\n    arrowNextDisabled: false,\n    breakpointsData: { list: [], current: null },\n    parallaxData: { translation: 0, slideshowOffsetTop: null },\n    conf: null\n  }),\n  created () {\n    this.conf = { ...this.$props }\n    delete this.conf.breakpoints // Prevent cyclic redundancy.\n  },\n  mounted () {\n    this.init()\n  },\n  methods: {\n    init () {\n      this.emit('before-init', false)\n      this.slides.count = this.slides.list.length\n\n      this.container = this.$refs.vueperslides\n\n      if (Object.keys(this.breakpoints).length) {\n        this.setBreakpointsList()\n        this.setBreakpointConfig(this.getCurrentBreakpoint())\n      }\n\n      this.touch.enabled = this.conf.touchable\n\n      if (this.conf.infinite && !this.conf.fade) {\n        this.cloneSlides()\n      }\n\n      this.goToSlide(this.conf.initSlide - 1)\n      this.bindEvents()\n\n      this.isReady = true\n      this.emit('ready')\n    },\n\n    // Emit a named event outside the component with 2 possible parameters:\n    // current slide info & next slide info.\n    emit(name, includeCurrentSlide = true, includeNextSlide = false) {\n      let args = [name]\n\n      if (includeCurrentSlide || typeof includeNextSlide === 'number') {\n        args[1] = {}\n        if (includeCurrentSlide && this.slides.activeUid) {\n          args[1].currentSlide = {\n            index: this.slides.current,\n            title: this.slides.list[this.slides.current].title,\n            content: this.slides.list[this.slides.current].content\n          }\n        }\n        if (typeof includeNextSlide === 'number') {\n          let { nextSlide } = this.getSlideInRange(includeNextSlide)\n          args[1].nextSlide = {\n            index: nextSlide,\n            title: this.slides.list[nextSlide].title,\n            content: this.slides.list[nextSlide].content\n          }\n        }\n      }\n\n      this.$emit(name, ...args)\n    },\n\n    setBreakpointsList () {\n      this.breakpointsData.list = [99999, ...Object.keys(this.breakpoints)].sort((a, b) => parseInt(a) < parseInt(b))\n    },\n\n    getCurrentBreakpoint () {\n      let windowWidth = window.innerWidth || document.documentElement.clientWidth || document.body.clientWidth\n      let breakpoints = [windowWidth, ...this.breakpointsData.list].sort((a, b) => parseInt(a) < parseInt(b))\n\n      return this.breakpointsData.list[breakpoints.indexOf(windowWidth) - 1]\n    },\n\n    hasBreakpointChanged (breakpoint) {\n      return this.breakpointsData.current !== breakpoint\n    },\n\n    setBreakpointConfig (breakpoint) {\n      this.breakpointsData.current = breakpoint\n      this.conf = { ...this.$props, ...(this.$props.breakpoints[breakpoint] || {}) }\n    },\n\n    cloneSlides () {\n      let firstNodeIsVnode = this.$slots.default[0].tag\n      let firstSlide = this.$slots.default[firstNodeIsVnode ? 0 : 1].elm\n      let lastSlide = this.$slots.default[this.$slots.default.length - 1].elm\n\n      this.clones[0] = {\n        title: this.slides.list[this.slides.count - 1].title,\n        content: this.slides.list[this.slides.count - 1].content,\n        image: this.slides.list[this.slides.count - 1].image,\n        style: lastSlide && lastSlide.attributes.style ? lastSlide.attributes.style.value : ''\n      }\n      this.clones[1] = {\n        title: this.slides.list[0].title,\n        content: this.slides.list[0].content,\n        image: this.slides.list[0].image,\n        style: firstSlide && lastSlide.attributes.style ? firstSlide.attributes.style.value : ''\n      }\n    },\n\n    bindEvents () {\n      const hasTouch = 'ontouchstart' in window\n\n      // Touch enabled slideshow.\n      if (this.touch.enabled) {\n        this.$refs.track.addEventListener(hasTouch ? 'touchstart' : 'mousedown', this.onMouseDown)\n        document.addEventListener(hasTouch ? 'touchmove' : 'mousemove', this.onMouseMove)\n        document.addEventListener(hasTouch ? 'touchend' : 'mouseup', this.onMouseUp)\n      }\n\n      // Pause autoplay on mouseover.\n      if (this.conf.pauseOnHover && !hasTouch && this.conf.autoplay) {\n        this.container.addEventListener('mouseover', this.onMouseIn)\n        this.container.addEventListener('mouseout', this.onMouseOut)\n      }\n\n      // Breakpoints or parallax need a resize event.\n      if (this.breakpointsData.list.length || this.parallax) {\n        window.addEventListener('resize', this.onResize)\n      }\n\n      // Parallax slideshow.\n      if (this.parallax) {\n        document.addEventListener('scroll', this.onScroll)\n      }\n    },\n\n    // Recursively sum all the offsetTop values from current element up the tree until body.\n    // By doing so a padding or margin on a parent won't cause a wrong calculation.\n    getSlideshowOffsetTop (force = false) {\n      if (this.parallaxData.slideshowOffsetTop === null || force) {\n        let el = this.container\n        let top = el.offsetTop\n\n        while (el = el.offsetParent) {\n          top += el.offsetTop\n        }\n\n        this.parallaxData.slideshowOffsetTop = top\n      }\n\n      return this.parallaxData.slideshowOffsetTop\n    },\n\n    onScroll (e) {\n      let doc = document.documentElement\n      let scrollTop = (window.pageYOffset || doc.scrollTop) - (doc.clientTop || 0)\n      let windowHeight = window.innerHeight || document.documentElement.clientHeight || document.body.clientHeight\n      let slideshowHeight = this.container.clientHeight\n      let slideshowTopOffset = this.getSlideshowOffsetTop()\n\n      // The distance between the bottom line of the current vueperslides slideshow and top of window.\n      // Negative value means the slideshow is totally above the current window box.\n      let vsBottom2WinTop = slideshowTopOffset + slideshowHeight - scrollTop\n      // The distance between the top line of the current vueperslides slideshow and bottom of window.\n      // Negative value means the slideshow is totally bellow the current window box.\n      let vsTop2winBottom = windowHeight + scrollTop - slideshowTopOffset\n\n      // Only apply translation when slideshow is visible.\n      if (vsBottom2WinTop > 0 && vsTop2winBottom > 0) {\n        let heightToCoverWithTranslation = windowHeight + slideshowHeight\n        let translatePercentage = 100 - (vsBottom2WinTop * 100 / heightToCoverWithTranslation)\n        this.parallaxData.translation = 50 - translatePercentage / 2\n      }\n    },\n\n    onResize () {\n      if (this.breakpointsData.list.length) {\n        let breakpoint = this.getCurrentBreakpoint()\n        if (this.hasBreakpointChanged(breakpoint)) {\n          this.setBreakpointConfig(breakpoint)\n        }\n      }\n\n      if (this.parallax) {\n        // Only refresh parallaxData.slideshowOffsetTop value on resize for better performance.\n        this.getSlideshowOffsetTop(true)\n      }\n    },\n\n    onMouseIn () {\n      this.mouseOver = true\n\n      if (this.conf.pauseOnHover && this.conf.autoplay) {\n        this.clearTimer()\n      }\n    },\n\n    onMouseOut () {\n      this.mouseOver = false\n\n      if (this.conf.pauseOnHover && this.conf.autoplay) {\n        this.setTimer()\n      }\n    },\n\n    onMouseDown (e) {\n      if (!this.touch.enabled || this.disable) return\n      if (!e.touches) e.preventDefault()\n\n      // this.disableScroll()\n\n      this.mouseDown = true\n\n      if (this.draggingDistance) {\n        // Store drag start in var for distance calculation in onMouseUp().\n        this.touch.dragStartX = 'ontouchstart' in window ? e.touches[0].clientX : e.clientX\n      } else {\n        let dragPercentage = this.getDragPercentage(e)\n\n        // Set a flag for use while dragging in `onMouseMove` to know if drag was toward left or right.\n        this.touch.goNext = dragPercentage >= 0.5\n\n        this.currentTranslation = - 100 * (this.slides.current + (this.touch.goNext ? 1 : 0) + (this.clones.length ? 1 : 0) - dragPercentage)\n      }\n    },\n\n    onMouseMove (e) {\n      if (this.mouseDown || this.touch.dragging) {\n        this.mouseDown = false\n        this.touch.dragging = true\n\n        if (this.draggingDistance) {\n          this.touch.dragAmount = this.getDragAmount(e)\n          let dragAmountPercentage = this.touch.dragAmount / this.container.clientWidth\n\n          this.currentTranslation = - 100 * (this.slides.current + (this.clones.length ? 1 : 0) - dragAmountPercentage)\n        } else {\n          let dragPercentage = this.getDragPercentage(e)\n          this.currentTranslation = - 100 * (this.slides.current + (this.touch.goNext ? 1 : 0) + (this.clones.length ? 1 : 0) - dragPercentage)\n        }\n      }\n    },\n\n    onMouseUp (e) {\n      if (this.mouseDown || this.touch.dragging) {\n        this.mouseDown = false\n        this.touch.dragging = false\n\n        let slideOnDragEnd\n        if (this.draggingDistance) {\n          let dragAmount = this.touch.dragAmount\n          let dragAmountPercentage = dragAmount / this.container.clientWidth\n\n          slideOnDragEnd = this.slides.current\n          if (Math.abs(dragAmount) >= this.draggingDistance) {\n            slideOnDragEnd += dragAmount > 0 ? -1 : 1\n          }\n        } else {\n          // When the drag is realeased, calculate if the drag ends before or after the 50%-slideshow-width threshold.\n          // Then finish the sliding toward that slide.\n          slideOnDragEnd = - (Math.round(this.currentTranslation / 100) + (this.clones.length ? 1 : 0))\n        }\n\n        let { nextSlide } = this.getSlideInRange(slideOnDragEnd)\n\n        // If drag is not allowed (`arrowNextDisabled` = true) and dragging beyond last slide,\n        // cancel sliding and snap back to last slide.\n        if (this.arrowNextDisabled && this.conf.autoplay && nextSlide === 0) {\n          nextSlide = this.slides.count - 1\n        }\n\n        // Only call `goToSlide` if the drag ends on a slide that is different than the currentSlide.\n        if (nextSlide !== this.slides.current) {\n          this.goToSlide(slideOnDragEnd)\n        } else {\n          // Apply transition to snap back to current slide.\n          this.currentTranslation = - (this.slides.current + (this.clones.length ? 1 : 0)) * 100\n        }\n\n        this.touch.dragStartX = null\n        this.touch.dragAmount = null\n        this.enableScroll()\n      }\n    },\n\n    getDragPercentage(e) {\n      let dragStartX = 'ontouchstart' in window ? e.touches[0].clientX : e.clientX\n\n      // For full window width slideshow only.\n      // let windowWidth = window.innerWidth || document.documentElement.clientWidth || document.body.clientWidth\n      // return dragStartX / windowWidth\n\n      return (dragStartX - this.container.offsetLeft) / this.container.clientWidth\n    },\n\n    /**\n     * Return the x distance in pixel between drag start and current drag position.\n     */\n    getDragAmount(e) {\n      return ('ontouchstart' in window ? e.touches[0].clientX : e.clientX) - this.touch.dragStartX\n    },\n\n    disableScroll () {\n      document.ontouchmove = function(e) {\n        e.preventDefault()\n      }\n    },\n\n    enableScroll () {\n      document.ontouchmove = function() {\n        return true\n      }\n    },\n\n    clearTimer () {\n      clearTimeout(this.timer)\n      this.timer = 0\n    },\n\n    setTimer () {\n      this.timer = setTimeout(() => {\n        this.goToSlide(this.slides.current + 1, true, true)\n      }, this.conf.speed)\n    },\n\n    onArrowClick (next = true) {\n      this.goToSlide(this.slides.current + (next ? 1 : -1))\n    },\n\n    getSlideInRange (i) {\n      let clone = null\n\n      // If infinite enabled, going out of range takes the first slide from the other end.\n      if (this.clones.length) {\n        if (i < 0) {\n          i = this.slides.count - 1\n          clone = 0\n        }\n        else if (i > this.slides.count - 1) {\n          i = 0\n          clone = 1\n        }\n      }\n\n      // If not infinite, can't go lower than 0 or beyond `slides.count` with `disableArrowsOnEdges`.\n      // If `disableArrowsOnEdges` is enabled going out of range will take first slide from the other end\n      // of the slideshow.\n      else {\n        if (i < 0) i = this.conf.disableArrowsOnEdges ? 0 : this.slides.count - 1\n        else if (i > this.slides.count - 1) {\n          // If autoplay is on but disableArrowsOnEdges is enabled, going beyond the last one will also bring\n          // the first one in.\n          i = this.conf.disableArrowsOnEdges ? (this.conf.autoplay ? 0 : this.slides.count - 1) : 0\n        }\n      }\n\n      return { nextSlide: i, clone: clone }\n    },\n\n    goToSlide (i, animation = true, autoSliding = false) {\n      if (!this.slides.count || this.disable) return\n\n      if (this.conf.autoplay) this.clearTimer()\n\n      let { nextSlide, clone: nextSlideIsClone } = this.getSlideInRange(i)\n\n      // First use of `goToSlide` is while init, so should not propagate an event.\n      if (this.isReady) this.emit('before-slide', true, nextSlide)\n\n      // Disable arrows if `disableArrowsOnEdges` is on and there is no slide to go to on that end.\n      if (this.conf.arrows && this.conf.disableArrowsOnEdges) {\n        this.arrowPrevDisabled = nextSlide === 0\n        this.arrowNextDisabled = nextSlide === this.slides.count - 1\n      }\n\n      this.$refs.track.classList[animation ? 'remove' : 'add']('vueperslides__track--no-animation')\n\n      // Infinite sliding with cloned slides:\n      // When reaching last slide and going next the cloned slide of the first slide\n      // shows up, when the animation ends the real change to the first slide is done\n      // immediately with no animation.\n      // Same principle when going beyond first slide.\n      if (nextSlideIsClone !== null) {\n        setTimeout(() => {\n          this.goToSlide(nextSlideIsClone ? 0 : this.slides.count - 1, false, autoSliding)\n        }, 400)\n      }\n\n      this.slides.current = nextSlide\n\n      // Only apply sliding transition when the slideshow animation type is `slide`.\n      if (!this.conf.fade) {\n        if (nextSlideIsClone !== null) {\n          this.currentTranslation = - 100 * (nextSlideIsClone ? this.slides.count + 1 : 0)\n        }\n        else this.currentTranslation = - 100 * (this.slides.current + (this.clones.length ? 1 : 0))\n      }\n\n      this.slides.activeUid = this.slides.list[this.slides.current]._uid\n\n      if (this.conf.autoplay && !this.mouseOver) {\n        this.setTimer()\n      }\n\n      if (this.slides.count) {\n        if (this.$slots.default[this.slides.current]) {\n          // First use of goToSlide is while init, so should not propagate an event.\n          if (this.isReady) this.emit('slide')\n        }\n\n        if (this.isReady && !autoSliding && this.$refs.bullet[this.slides.current]) {\n          this.$refs.bullet[this.slides.current].focus()\n        }\n      }\n    },\n\n    addSlide(newSlide) {\n      const needReclone = this.conf.infinite && !this.conf.fade && this.isReady && !newSlide.clone\n\n      if (newSlide.clone !== null) {\n        this.clones[newSlide.clone] = newSlide\n      }\n\n      else {\n        // Add the slide in the slides array & update slides.count.\n        this.slides.list.push(newSlide)\n        this.slides.count = this.slides.list.length\n      }\n\n      if (this.slides.count > 1 && this.touchable) {\n        this.touch.enabled = true\n      }\n\n      if (needReclone) {\n        this.$nextTick(() => this.cloneSlides())\n      }\n    },\n\n    removeSlide(uid) {\n      // let needReclone = this.infinite && !this.fade && this.isReady\n      let needReclone = false\n\n      this.slides.list.some((slide, i) => {\n        if (slide._uid === uid) {\n          // Remove the slide.\n          this.slides.list.splice(i, 1)\n          this.slides.count = this.slides.list.length\n\n          // If the slide to remove is the current slide, slide to the previous slide.\n          if (uid === this.slides.activeUid) {\n            this.slides.activeUid = null\n            this.goToSlide(i - 1, true, true)\n          }\n\n          if (this.slides.count <= 1) {\n            this.touch.enabled = false\n          }\n\n          if (this.clones.length && this.isReady && !slide.clone) needReclone = true\n\n          return true // Break the `Array.some` loop.\n        }\n      })\n\n      if (this.slides.count && needReclone) {\n        this.cloneSlides()\n      }\n    }\n  }\n}\n</script>\n\n<style lang=\"scss\">\n.vueperslides {\n  position: relative;\n\n  &__inner {\n    position: relative;\n  }\n\n  &__parallax-wrapper {\n    position: relative;\n    padding-bottom: 33.33%;\n    overflow: hidden;\n\n    &::before,\n    &::after {\n      content: \"\";\n      position: absolute;\n      bottom: 100%;\n      left: -1em;\n      right: -1em;\n      height: 2em;\n      box-shadow: 0 0 20px rgba(#000, 0.25);\n      z-index: 2;\n    }\n\n    &::after {\n      top: 100%;\n      bottom: auto;\n    }\n  }\n\n  &__track-wrapper {\n    position: absolute;\n    top: 0;\n    height: 100%;\n    left: 0;\n    right: 0;\n    overflow: hidden;\n    z-index: 1;\n\n  }\n\n  &--parallax &__track-wrapper {\n    height: 200%;\n    transform: translateY(0);\n  }\n\n  &--fade &__track {\n    white-space: normal;\n    transition: none;\n  }\n\n  &--touchable &__track {\n    cursor: ew-resize;\n    cursor: -webkit-grab;\n    cursor: grab;\n\n    &--mousedown, &--dragging {\n      cursor: -webkit-grabbing;\n      cursor: grabbing;\n    }\n  }\n\n  &__track {\n    white-space: nowrap;\n    transition: 0.5s ease-in-out transform;\n    height: 100%;\n\n    &--mousedown {\n      transition: 0.2s ease-in-out transform;\n    }\n\n    &--dragging {\n      transition: none;\n    }\n\n    &--no-animation {\n      transition-duration: 0s;\n    }\n  }\n\n  &__slide {\n    white-space: normal;\n    background-position: top;\n    background-size: cover;\n    display: inline-block;\n    width: 100%;\n    height: 100%;\n  }\n\n  &__slide-content {\n    user-select: none;\n\n    &--outside {\n      user-select: initial;\n    }\n  }\n\n  &--fade &__slide {\n    position: absolute;\n    top: 0;\n    left: 0;\n    right: 0;\n    bottom: 0;\n    opacity: 0;\n    transition: .8s ease-in-out opacity;\n\n    &--active {\n      z-index: 1;\n      opacity: 1;\n    }\n  }\n\n  &__arrow {\n    position: absolute;\n    top: 50%;\n    background-color: transparent;\n    border: none;\n    color: #fff;\n    fill: currentColor;\n    font-size: 3em;\n    width: 1em;\n    text-align: center;\n    transform: translateY(-50%);\n    opacity: 0.7;\n    transition: 0.3s ease-in-out;\n    cursor: pointer;\n    user-select: none;\n    outline: none;\n    z-index: 2;\n\n    &--prev {\n      left: 10px;\n    }\n\n    &--next {\n      right: 10px;\n    }\n\n    &:hover {\n      opacity: 1;\n    }\n  }\n\n  &__paused {\n    position: absolute;\n    top: 3%;\n    right: 3%;\n    opacity: 0;\n    transition: 0.3s ease-in-out;\n    text-shadow: 0 0 3px rgba(#000, .4);\n    z-index: 1;\n  }\n\n  &:hover &__paused {\n    opacity: 1;\n  }\n\n  &__bullets {\n    display: flex;\n    justify-content: center;\n    position: absolute;\n    bottom: 0;\n    left: 0;\n    right: 0;\n\n    &--outside {\n      position: relative;\n    }\n  }\n\n  &__bullet {\n    width: 12px;\n    height: 12px;\n    border-radius: 12px;\n    border: 1px solid #fff;\n    background-color: transparent;\n    box-shadow: 0 0 1px rgba(#000, 0.5), 0 0 3px rgba(#000, 0.3);\n    margin: 1.5em 0.6em;\n    padding: 0;\n    display: inline-block;\n    cursor: pointer;\n    user-select: none;\n    outline: none;\n    z-index: 2;\n    display: flex;\n    justify-content: center;\n    align-items: center;\n\n    &--active {\n      background-color: #fff;\n    }\n\n    &::-moz-focus-inner {\n      border: 0;\n    }\n\n    span {\n      display: none;\n    }\n  }\n}\n</style>\n","import VueperSlides from './components/VueperSlides.vue'\nimport VueperSlide from './components/VueperSlide.vue'\n\n// Expose component to global scope.\nif (typeof window !== 'undefined' && window.Vue) {\n  window.Vue.component('vueper-slides', VueperSlides)\n  window.Vue.component('vueper-slide', VueperSlide)\n}\n\nexport { VueperSlides, VueperSlide }\n"],"names":["render","Number","String","$parent","addSlide","this","_uid","image","title","content","clone","removeSlide","backgroundImage","VueperSlide","Boolean","Object","list","count","activeUid","current","clones","enabled","dragging","dragStartX","dragAmount","goNext","translation","slideshowOffsetTop","conf","$props","breakpoints","init","emit","slides","length","container","$refs","vueperslides","keys","setBreakpointsList","setBreakpointConfig","getCurrentBreakpoint","touch","touchable","infinite","fade","cloneSlides","goToSlide","initSlide","bindEvents","isReady","name","includeCurrentSlide","includeNextSlide","args","currentSlide","nextSlide","getSlideInRange","$emit","breakpointsData","sort","a","b","parseInt","windowWidth","window","innerWidth","document","documentElement","clientWidth","body","indexOf","breakpoint","firstNodeIsVnode","$slots","default","tag","firstSlide","elm","lastSlide","attributes","style","value","hasTouch","track","addEventListener","onMouseDown","onMouseMove","onMouseUp","pauseOnHover","autoplay","onMouseIn","onMouseOut","parallax","onResize","onScroll","force","parallaxData","el","top","offsetTop","offsetParent","e","doc","scrollTop","pageYOffset","clientTop","windowHeight","innerHeight","clientHeight","slideshowHeight","slideshowTopOffset","getSlideshowOffsetTop","vsBottom2WinTop","translatePercentage","hasBreakpointChanged","mouseOver","clearTimer","setTimer","disable","touches","preventDefault","mouseDown","draggingDistance","clientX","dragPercentage","getDragPercentage","currentTranslation","getDragAmount","dragAmountPercentage","slideOnDragEnd","Math","abs","round","arrowNextDisabled","enableScroll","offsetLeft","ontouchmove","timer","setTimeout","_this","speed","next","i","disableArrowsOnEdges","animation","autoSliding","nextSlideIsClone","arrows","arrowPrevDisabled","classList","_this2","bullet","focus","newSlide","needReclone","push","$nextTick","_this3","uid","some","slide","splice","_this4","Vue","component","VueperSlides"],"mappings":"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"}